/*
 * Programs to load into 1802 Cosmac Elf
 */


int data_size = 0;

//Program 2 - The original Cosmac Elf spaceship program by Joseph Weisbecker
//  modified to run in any page and to toggle Q instead of over-writing code
//  when the input button is pressed.
const uint8_t spaceship[] PROGMEM = {
  // program code (upper 25% of the screen contains display code)
  0x90, 0xB1, 0xB2, 0xB3, 0xB4, 0xF8, 0x2D, 0xA3,
  0xF8, 0x3F, 0xA2, 0xF8, 0x11, 0xA1, 0xD3, 0x72,
  //0x0010
  //Patch to keep interrupt cycles and byte count same
  0x70, 0x22, 0x78, 0x22, 0x52, 0xC4, 0xE2, 0xE2,
  //Patch to set R0 to page image location
  0xE2, 0x91, 0xB0, 0xF8, 0x00, 0xA0, 0x80, 0xE2,
  //0x0020
  0xE2, 0x20, 0xA0, 0xE2, 0x20, 0xA0, 0xE2, 0x20,
  0xA0, 0x3C, 0x1E, 0x30, 0x0F, 0xE2, 0x69, 0x3F,
  //0x0030
  //Patch - Toggle Q instead of over-writing memory (ROM)
  0x2F, 0x37, 0x31, 0xCD, 0x7B, 0x38, 0x7A, 0x30,
  0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //0x0040
  // bitmap  (the bottom 75% of the screen is the bitmap)
  0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
  0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
  0x7B,   0xDE,   0xDB,   0xDE,   0x00,   0x00,   0x00,   0x00, 
  0x4A,   0x50,   0xDA,   0x52,   0x00,   0x00,   0x00,   0x00, 
  0x42,   0x5E,   0xAB,   0xD0,   0x00,   0x00,   0x00,   0x00, 
  0x4A,   0x42,   0x8A,   0x52,   0x00,   0x00,   0x00,   0x00, 
  0x7B,   0xDE,   0x8A,   0x5E,   0x00,   0x00,   0x00,   0x00, 
  0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
  0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x07,   0xE0, 
  0x00,   0x00,   0x00,   0x00,   0xFF,   0xFF,   0xFF,   0xFF, 
  0x00,   0x06,   0x00,   0x01,   0x00,   0x00,   0x00,   0x01, 
  0x00,   0x7F,   0xE0,   0x01,   0x00,   0x00,   0x00,   0x02, 
  0x7F,   0xC0,   0x3F,   0xE0,   0xFC,   0xFF,   0xFF,   0xFE, 
  0x40,   0x0F,   0x00,   0x10,   0x04,   0x80,   0x00,   0x00, 
  0x7F,   0xC0,   0x3F,   0xE0,   0x04,   0x80,   0x00,   0x00, 
  0x00,   0x3F,   0xD0,   0x40,   0x04,   0x80,   0x00,   0x00, 
  0x00,   0x0F,   0x08,   0x20,   0x04,   0x80,   0x7A,   0x1E, 
  0x00,   0x00,   0x07,   0x90,   0x04,   0x80,   0x42,   0x10, 
  0x00,   0x00,   0x18,   0x7F,   0xFC,   0xF0,   0x72,   0x1C, 
  0x00,   0x00,   0x30,   0x00,   0x00,   0x10,   0x42,   0x10, 
  0x00,   0x00,   0x73,   0xFC,   0x00,   0x10,   0x7B,   0xD0, 
  0x00,   0x00,   0x30,   0x00,   0x3F,   0xF0,   0x00,   0x00, 
  0x00,   0x00,   0x18,   0x0F,   0xC0,   0x00,   0x00,   0x00, 
  0x00,   0x00,   0x07,   0xF0,   0x00,   0x00,   0x00,   0x00 
};

//Program 3 -- Tom Pittman's TV Digital clock program
const uint8_t tv_digital_clock[] PROGMEM = {
  0x90, 0xB1, 0xB2, 0xB3, 0xF8, 0x1B, 0xA1, 0xF8, 
  0xFF, 0xA2, 0xF8, 0x0F, 0xA3, 0x70, 0x23, 0x69,
  0x30, 0xAC, 0x12, 0x42, 0xF6, 0x42, 0xB7, 0x42,
  0xA7, 0x42, 0x70, 0xC4, 0x22, 0x78, 0x22, 0x73,
  0x87, 0x73, 0x97, 0x73, 0x7E, 0x73, 0xF8, 0xC8,
  0x34, 0x28, 0xA0, 0xA0, 0xB7, 0xF8, 0x0B, 0xA7,
  0x97, 0xA0, 0x27, 0x97, 0xA0, 0xA0, 0x87, 0x3A,
  0x32, 0x80, 0x3C, 0x2A, 0xA0, 0x34, 0x3C, 0x90,
  0xB7, 0xF8, 0xC7, 0xA7, 0x07, 0xFC, 0x01, 0x57,
  //Counter value at 0049 changed from 0x3D (61) to 0x1B (27)
  0xFF, 0x1B, 0x3B, 0x12, 0xE7, 0x73, 0xF0, 0xFC,
  0x03, 0x57, 0x3B, 0x69, 0xF8, 0xE2, 0x73, 0xF0,
  0xFC, 0x03, 0x57, 0xFC, 0x0C, 0x3B, 0x62, 0xF8,
  0xE2, 0x57, 0xF8, 0xC8, 0x30, 0x6B, 0xF8, 0xC6,
  0xA7, 0xF8, 0xCC, 0xA0, 0x47, 0xFC, 0xAC, 0xA7,
  0x47, 0x52, 0xE2, 0xF0, 0xFE, 0x52, 0x75, 0x50,
  0x10, 0x80, 0xFA, 0x03, 0x3A, 0x73, 0x10, 0x10,
  0x10, 0x10, 0xF0, 0x3A, 0x73, 0x80, 0xFF, 0xF8,
  0x3B, 0x70, 0x32, 0x66, 0x30, 0x12, 0xDA, 0xAA,
  0xDF, 0xD9, 0xDD, 0x8F, 0x9E, 0xDB, 0x8F, 0x9E,
  0xDE, 0x9F, 0xEA, 0xA8, 0xEF, 0x8B, 0x9E, 0x9F,
  0xCB, 0x9A, 0xDF, 0x8E, 0xDB, 0xBF, 0xDA, 0xDA,
  0xDF, 0xDA, 0xCE, 0xDF, 0xE7, 0xA7, 0x3B, 0xB1,
  0x17, 0x60, 0x7C, 0x01, 0x3A, 0xB1, 0xE2, 0x87,
  0x22, 0x52, 0x64, 0x32, 0xBF, 0x3F, 0xBD, 0x37,
  0xBF, 0x6C, 0xFE, 0x30, 0xAC, 0xE2, 0xE2, 0x00
};

//Program 4 - Quick video DMA test, based on Tom Pittman's program
const uint8_t video_dma_test[] PROGMEM = {
  0x90, 0xB1, 0xB2, 0xB3, 0xF8, 0x1B, 0xA1, 0xF8,
  0xFF, 0xA2, 0xF8, 0x0F, 0xA3, 0x71, 0x23, 0x69,
  0xF8, 0x18, 0xA0, 0x30, 0x10, 0x00, 0x00, 0x00,
  //Replace these values with any pattern you prefer
  0x55, 0x55, 0x99, 0x99, 0XEE, 0xEE, 0x0F, 0x0F  
};

//Program 5 - EETops Monitor program
//
//  Extended ETOPS by Mike Riley
//
//  This program is an extension of the ETOPS program from Popular Electronics. 
//  This version allows for full 16-bit addresses.
//
//  This program is used by first placing the desired function code on the switches
//  and then placing the computer into run mode. At this point the computer will 
//  wait for the high portion of the address. Enter the high byte of the address on the
//  switches and then press the IN button. Then the computer will wait for the low byte
//  of the address. Again, enter this portion of the address on the switches and press
//  the IN button. Then the program will perform the requested function:
//
//    00 - Run program. The program will execute with R0
//    01 - Examine Memory. This function allows you to examine memory, while the IN button is
//         pressed, the data displays will show the next low address to be displayed. When the IN
//         button is released, the data byte will be displayed.
//    02 - Modify Memory. This function allows you to enter bytes into memory. Like the 01 function,
//         while the IN button is pressed, the low address of the next address to be written will be
//         displayed, when IN is released the toggles will be read and the value stored into memory.
//         In this mode the Q led will be lit to remind you that you are in modify mode.
const uint8_t eetops_monitor[] PROGMEM = {
  0x90, 0xB2, 0xF8, 0x3B, 0xA2, 0xE2, 0x90, 0xB3, 
  0xF8, 0x0C, 0xA3, 0xD3, 0x6C, 0x64, 0x22, 0xA1,
  0x3F, 0x10, 0x37, 0x12, 0x6C, 0x64, 0x22, 0xB0, 
  0x3F, 0x18, 0x37, 0x1A, 0x6C, 0x64, 0x22, 0xA0,
  0x81, 0x3A, 0x24, 0xD0, 0xFF, 0x01, 0x32, 0x29, 
  0x7B, 0x3F, 0x29, 0x80, 0x52, 0x64, 0x22, 0x37, 
  0x2F, 0x39, 0x35, 0x6C, 0x50, 0x40, 0x52, 0x64, 
  0x22, 0x30, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00
};


//Program 6 - Game of Life program
//  
//    Conway's Game of Life
//
//  http://www.radicaleye.com/lifepage/
//  http://www.math.com/students/wonders/life/life.html
//
//Implemented on Cosmac Elf by Josh Bensadon,  Sept 2003
//
//This is a simulation game.  The entire screen is a 2 dimensional
//world for these cells.  Each cell has 8 neighbors (above, below,
//right, left, and 4 diagonal corners).  If a cell is alive and
//has exactly 2 or 3 neighbors, it remains alive.  If less than 2,
//it dies of loniness, more than 3 it's over crowded.  If a cell
//is not alive, and there are exactly 3 neighbors, it will come
//alive in the next cycle.
//
//Load the game at 0x0000,  it uses 3 pages.
//It requires pages 6 and 7 for video (it fills the alternate page).
//Hence, program requires 2K of ram.
//
//Turn Data switch 7 ON (Input mode) [Enter 80 on Hex keypad]
// 
//Turn Run switch ON
// 
//Input Mode:
//   Switch 6 does a Clear Screen.  [Enter C0 on Hex Keypad]
//   Switch 0 moves cursor right    [Enter 81 on Hex Keypad]
//   Switch 1  "      "    left     [Enter 82 on Hex Keypad]  
//   Switch 2  "      "    down     [Enter 84 on Hex Keypad]
//   Switch 3  "      "    up       [Enter 88 on Hex Keypad]
//   Input Switch toggles the pixel (cell).  Holding this switch down
//   will set/reset many cells if the cursor is moving in any direction.
//
//   Set your pattern, or use the random pattern that was in the undefined
//   RAM space.
//
//   Turn Switch 7 OFF  (Run Mode)
//    [Enter 00 on Hex Keypad]
//Run Mode:
//Hex display shows the current generation (00-FF, then loops)
//Sit back and watch the game of life!
//
//Turn Switch 7 ON at any time to return to Input Mode
//
//
//Enjoy!
const uint8_t game_of_life[] PROGMEM = {
  //Address: 0x0000 (Page 0)
  0x90, 0xB1, 0xB2, 0xB3, 0xAB, 0xF8, 0x02, 0xBA, 0xB4, 0xF8, 0x09, 0xA4, 0xF8, 0x19, 0xA1, 0xF8,
  0x3D, 0xA2, 0xF8, 0x3E, 0xA3, 0xE2, 0xD3, 0x72, 0x70, 0x22, 0x78, 0x22, 0x52, 0xC4, 0xF8, 0x00,
  0xA0, 0x9B, 0xB0, 0xE2, 0xE2, 0xE2, 0x80, 0xE2, 0xE2, 0x20, 0xA0, 0xE2, 0x20, 0xA0, 0xE2, 0x20,
  0xA0, 0x3C, 0x26, 0x30, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0xF8,
  //Address: 0x0040
  0x07, 0xBB, 0x6C, 0xFA, 0x80, 0x3A, 0x4A, 0xC0, 0x01, 0x00, 0x6C, 0xFA, 0x40, 0x32, 0x61, 0x93,
  0xAB, 0x93, 0x5B, 0x1B, 0x8B, 0x3A, 0x51, 0x2B, 0xAB, 0xAC, 0x6C, 0xFA, 0x7F, 0x3A, 0x5A, 0x30,
  0x42, 0xEB, 0x8C, 0xFA, 0x07, 0xAA, 0x0A, 0xF3, 0x00, 0x00, 0x5B, 0x0A, 0xF3, 0x00, 0x00, 0x5B,
  0x3F, 0x88, 0x9C, 0x3A, 0x7E, 0x0A, 0xF2, 0x32, 0x7B, 0xF8, 0x01, 0xF9, 0x02, 0xBC, 0xF6, 0x0A,
  //Address: 0x0080  
  0x3B, 0x86, 0xFB, 0xFF, 0xF2, 0x38, 0xF1, 0x5B, 0xE2, 0x6C, 0xFA, 0x01, 0x3A, 0xB6, 0x6C, 0xFA,
  0x02, 0x3A, 0xA9, 0x6C, 0xFA, 0x04, 0x3A, 0xA4, 0x6C, 0xFA, 0x08, 0x3A, 0x9F, 0x30, 0xC2, 0x8B,
  0xFF, 0x08, 0x30, 0xC1, 0x8B, 0xFC, 0x08, 0x30, 0xC1, 0x8C, 0xFC, 0xFF, 0xFA, 0x07, 0xAC, 0x33,
  0xC2, 0x8B, 0xFF, 0x01, 0x30, 0xC1, 0x8C, 0xFC, 0x01, 0xFA, 0x07, 0xAC, 0x3A, 0xC2, 0x8B, 0xFC,
  //Address: 0x00C0
  0x01, 0xAB, 0x00, 0x00, 0x00, 0x37, 0x42, 0xF8, 0x00, 0xBC, 0x30, 0x42, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //Address: 0x0100 (Page 1)
  0xBF, 0xE2, 0x9B, 0xFB, 0x01, 0xB5, 0xF8, 0x00, 0xA5, 0x85, 0xAB, 0xF8, 0x00, 0xA8, 0xAE, 0xAF,
  0x0B, 0xA6, 0x8B, 0xFC, 0x08, 0xAB, 0x0B, 0xB7, 0x8B, 0xFF, 0x10, 0xAB, 0x0B, 0xA7, 0x8B, 0xFA,
  0xF8, 0x52, 0x8B, 0xFC, 0x01, 0xFA, 0x07, 0xF1, 0xAB, 0x0B, 0xFE, 0x3B, 0x2E, 0x18, 0x8B, 0xFC,
  0x08, 0xAB, 0x0B, 0xFE, 0x3B, 0x37, 0x18, 0x8B, 0xFC, 0x08, 0xAB, 0x0B, 0xFE, 0x3B, 0x40, 0x18,
  //Address: 0x0140
  0x8B, 0xFF, 0x10, 0xFA, 0xF8, 0x52, 0x8B, 0xFF, 0x02, 0xFA, 0x07, 0xF1, 0xAB, 0x0B, 0xF6, 0x3B,
  0x52, 0x1F, 0x8B, 0xFC, 0x08, 0xAB, 0x0B, 0xF6, 0x3B, 0x5B, 0x1F, 0x8B, 0xFC, 0x08, 0xAB, 0x0B,
  0xF6, 0x3B, 0x64, 0x1F, 0x8E, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0x87, 0xF6, 0x3B, 0x70, 0x18, 0x19,
  0xF6, 0x3B, 0x76, 0x18, 0x19, 0x1A, 0xF6, 0x3B, 0x7C, 0x19, 0x1A, 0x1B, 0xF6, 0x3B, 0x82, 0x1A,
  //Address: 0x0180
  0x1B, 0x1C, 0xF6, 0x3B, 0x88, 0x1B, 0x1C, 0x1D, 0xF6, 0x3B, 0x8E, 0x1C, 0x1D, 0x1E, 0xF6, 0x3B,
  0x94, 0x1D, 0x1E, 0x1F, 0x32, 0x98, 0x1E, 0x1F, 0xD4, 0x85, 0xFC, 0x01, 0xA5, 0x3A, 0x09, 0x95,
  0xBB, 0x9F, 0xFC, 0x01, 0xBF, 0x52, 0x64, 0x22, 0x6C, 0xFA, 0x80, 0x32, 0x01, 0xC0, 0x00, 0x42,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //Address: 0x01C0
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //Address: 0x0200 (Page 2)
  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0xD3, 0x97, 0xF6, 0x3B, 0x0F, 0x18, 0x19, 0xF6,
  0x3B, 0x15, 0x18, 0x19, 0x1A, 0xF6, 0x3B, 0x1B, 0x19, 0x1A, 0x1B, 0xF6, 0x3B, 0x21, 0x1A, 0x1B,
  0x1C, 0xF6, 0x3B, 0x27, 0x1B, 0x1C, 0x1D, 0xF6, 0x3B, 0x2D, 0x1C, 0x1D, 0x1E, 0xF6, 0x3B, 0x33,
  0x1D, 0x1E, 0x1F, 0x32, 0x37, 0x1E, 0x1F, 0x86, 0xF6, 0x3B, 0x3C, 0x19, 0xF6, 0x3B, 0x41, 0x18,
  //Address: 0x0240
  0x1A, 0xF6, 0x3B, 0x46, 0x19, 0x1B, 0xF6, 0x3B, 0x4B, 0x1A, 0x1C, 0xF6, 0x3B, 0x50, 0x1B, 0x1D,
  0xF6, 0x3B, 0x55, 0x1C, 0x1E, 0xF6, 0x3B, 0x5A, 0x1D, 0x1F, 0x32, 0x5D, 0x1E, 0x28, 0x28, 0x29,
  0x29, 0x8A, 0xFF, 0x02, 0xAA, 0x8B, 0xFF, 0x02, 0xAB, 0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x8F,
  0xFF, 0x02, 0xAF, 0x88, 0x32, 0x7D, 0xFF, 0x01, 0x32, 0x7F, 0xFE, 0x30, 0x7E, 0x86, 0xF6, 0x96,
  //Address: 0x0280
  0x76, 0xB6, 0x89, 0x32, 0x8C, 0xFF, 0x01, 0x32, 0x8F, 0xFE, 0x30, 0x8E, 0x86, 0xF6, 0xF6, 0x96,
  0x76, 0xB6, 0x8A, 0x32, 0x9C, 0xFF, 0x01, 0x32, 0xA0, 0xFE, 0x30, 0x9F, 0x86, 0xF6, 0xF6, 0xF6,
  0x96, 0x76, 0xB6, 0x8B, 0x32, 0xAD, 0xFF, 0x01, 0x32, 0xB2, 0xFE, 0x30, 0xB1, 0x86, 0xF6, 0xF6,
  0xF6, 0xF6, 0x96, 0x76, 0xB6, 0x8C, 0x32, 0xBF, 0xFF, 0x01, 0x32, 0xC4, 0xF6, 0x30, 0xC3, 0x86,
  //Address: 0x02C0
  0xFE, 0xFE, 0xFE, 0xFE, 0x96, 0x76, 0xB6, 0x8D, 0x32, 0xD1, 0xFF, 0x01, 0x32, 0xD5, 0xF6, 0x30,
  0xD4, 0x86, 0xFE, 0xFE, 0xFE, 0x96, 0x76, 0xB6, 0x8E, 0x32, 0xE2, 0xFF, 0x01, 0x32, 0xE5, 0xF6,
  0x30, 0xE4, 0x86, 0xFE, 0xFE, 0x96, 0x76, 0xB6, 0x8F, 0x32, 0xF2, 0xFF, 0x01, 0x32, 0xF4, 0xF6,
  0x30, 0xF3, 0x86, 0xFE, 0x96, 0x76, 0x55, 0x30, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//Get Character for a Hex value for a nibble (0-F)
char getNibbleChar(byte h_value) {
  char c_hex = '0';
  
  if (h_value < 10) {
    //Nibbles 0 - 9
    c_hex = '0' + h_value;  
  } else {
    //Nibbles A - F
    c_hex = 'A' + (h_value - 10);  
  }
  return c_hex;
} //getNibbleChar

//Get the charcter for a Hex Digit in a byte value 
// data - byte value (0x00 to 0xFF)
// digit - 0 for High Nibble, 1 for Low Nibble
char getHexDigitChar(byte data, byte digit) {
  char c_nibble = '0';
  
  if (digit == 0) {
    c_nibble = getNibbleChar((data & 0xF0) >> 4);
  } else {
    c_nibble = getNibbleChar(data & 0x0F);
  } //if digit == 0

  return c_nibble;
} //getHexDigitChar

//Get the next character from a hexidecimal program byte
char getNextByteChar(byte program_type, int offset, byte nibble) {
  char c_byte = 'F'; //Default to all F's
  int  pgm_size = 0;
  byte pgm_data = 0;

  //Check variables for valid range
  if (nibble < 2 && offset < pgm_page_size) {
    switch (program_type) {
      //Load all zeros
      case PGM_ZEROS:
        c_byte = '0';
      break;
      //Load a sequence of digits in the page
      case PGM_SEQUENCE:
        //As the offset goes from 0 to 0xFF get the hex character for each nibble
        c_byte = getHexDigitChar(offset, nibble);
      break;

      //Load the classic spaceship program in the page
      case PGM_SPACESHIP:              
        pgm_data = pgm_read_byte_near(spaceship + offset);
        c_byte = getHexDigitChar(pgm_data, nibble);
      break;

      case PGM_TV_CLOCK:
        if (offset < sizeof(tv_digital_clock)) {              
          pgm_data = pgm_read_byte_near(tv_digital_clock + offset);
          c_byte = getHexDigitChar(pgm_data, nibble);
        } else {
          //Pad with zeros until the end of page
          c_byte = '0';
        } //if-else offset < sizeof tv_digital_clock
      break;
      
      case PGM_VIDEO_TEST:
        if (offset < sizeof(video_dma_test)) {              
          pgm_data = pgm_read_byte_near(video_dma_test + offset);
          c_byte = getHexDigitChar(pgm_data, nibble);
        } else {
          //Pad with zeros until the end of page
          c_byte = '0';
        } //if-else offset < sizeof tv_digital_clock
      break;

      case PGM_MONITOR:
        if (offset < sizeof(eetops_monitor)) {              
          pgm_data = pgm_read_byte_near(eetops_monitor + offset);
          c_byte = getHexDigitChar(pgm_data, nibble);
        } else {
          //Pad with zeros until the end of page
          c_byte = '0';
        } //if-else offset < sizeof eetops_monitor
      break;      

      case PGM_LIFE:
        if (offset < sizeof(game_of_life)) {              
          pgm_data = pgm_read_byte_near(game_of_life + offset);
          c_byte = getHexDigitChar(pgm_data, nibble);
        } else {
          //Pad with zeros until the end of page
          c_byte = '0';
        } //if-else offset < sizeof eetops_monitor
      break;        
                       
      //Send all F's for any undefined case
      default:
        //Do nothing
      break;        
    } // switch
  } // if nibble < 2 && offset < pgm_page_size
#if DEBUG
  Serial.print(c_byte);
#endif
  return c_byte;
} //getNextByteChar
